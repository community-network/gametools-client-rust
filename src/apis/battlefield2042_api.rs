/*
 * Stats API for the Battlefield series
 *
 * This project also has a <a href=\"https://top.gg/bot/714524944783900794\" target=\"_blank\">Discord bot</a>, allowing anyone in your server to check their Battlefield stats via simple commands.<br><br>Language tags (lang) for both Battlefield 1 and Battlefield 5 are based on <a href=\"https://www.oracle.com/java/technologies/javase/jdk8-jre8-suported-locales.html\" target=\"_blank\">Java 8 language tags.</a> (response keys do not change based on the language tags, only the values do).<br><br>Data for Battlefield 2 is retrieved from the two revive projects: <a href=\"https://www.bf2hub.com\" target=\"_blank\">BF2Hub</a> and <a href=\"https://playbf2.tilda.ws/en\" target=\"_blank\">PlayBF2</a>.<br><br>Data for Battlefield 2142 is retrieved from the <a href=\"https://battlefield2142.co/\" target=\"_blank\">BF2142 Reclamation</a> project.<br><br>All other titles are still managed by EA/Dice.<br><br>If you discover any issues or have suggestions for new features, post them in the Community Network Discord: <a href=\"https://discord.gg/zMuxW6c\" target=\"_blank\">discord.gg/zMuxW6c</a>.<br><br>If you want to support the project, consider <a href=\"https://github.com/sponsors/community-network\" target=\"_blank\">becoming a sponsor on GitHub</a>.
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bf2042_available_tags_bf2042_availabletags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042AvailableTagsBf2042AvailabletagsGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_collections_bf2042_scheduledcollections_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042CollectionsBf2042ScheduledcollectionsGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_get_feslid_bf2042_feslid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042GetFeslidBf2042FeslidGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_get_progression_types_bf2042_progressiontypes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042GetProgressionTypesBf2042ProgressiontypesGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_get_store_catalog_bf2042_storecatalog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042GetStoreCatalogBf2042StorecatalogGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_mix_info_bf2042_mixinfo_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042MixInfoBf2042MixinfoGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_offers_bf2042_offers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042OffersBf2042OffersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_playground_bf2042_playground_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042PlaygroundBf2042PlaygroundGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042_post_feslid_bf2042_feslid_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042PostFeslidBf2042FeslidPostError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042blueprints_bf2042_scheduledblueprint_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042blueprintsBf2042ScheduledblueprintGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042constraints_bf2042_constraints_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042constraintsBf2042ConstraintsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042detailed_servers_bf2042_detailedserver_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042detailedServersBf2042DetailedserverGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042inventory_bf2042_inventory_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042inventoryBf2042InventoryGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042multiple_bf2042_multiple_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042multipleBf2042MultiplePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042player_bf2042_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042playerBf2042PlayerGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042servers_bf2042_servers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042serversBf2042ServersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042stats_bf2042_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042statsBf2042StatsGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf2042translations_bf2042_translations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf2042translationsBf2042TranslationsGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`game_status_bf2042_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameStatusBf2042StatusGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logged_server_data_bf2042_serverarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoggedServerDataBf2042ServerarrayGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_logged_data_bf2042_statusarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintLoggedDataBf2042StatusarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`statsarray_bf2042_statsarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatsarrayBf2042StatsarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


pub async fn bf2042_available_tags_bf2042_availabletags_get(configuration: &configuration::Configuration, lang: Option<&str>) -> Result<models::AvailableTagsResponse, Error<Bf2042AvailableTagsBf2042AvailabletagsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/availabletags/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvailableTagsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvailableTagsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042AvailableTagsBf2042AvailabletagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_collections_bf2042_scheduledcollections_get(configuration: &configuration::Configuration, lang: Option<&str>) -> Result<models::ScheduledCollectionsResponse, Error<Bf2042CollectionsBf2042ScheduledcollectionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/scheduledcollections/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledCollectionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledCollectionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042CollectionsBf2042ScheduledcollectionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns username and avatar based on the given info (get request for CORS)
pub async fn bf2042_get_feslid_bf2042_feslid_get(configuration: &configuration::Configuration, platformid: Option<i32>, personaid: Option<i32>, nucleusid: Option<i32>) -> Result<models::FeslPlayerInfo, Error<Bf2042GetFeslidBf2042FeslidGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_platformid = platformid;
    let p_personaid = personaid;
    let p_nucleusid = nucleusid;

    let uri_str = format!("{}/bf2042/feslid/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_platformid {
        req_builder = req_builder.query(&[("platformid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_personaid {
        req_builder = req_builder.query(&[("personaid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_nucleusid {
        req_builder = req_builder.query(&[("nucleusid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeslPlayerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeslPlayerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042GetFeslidBf2042FeslidGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_get_progression_types_bf2042_progressiontypes_get(configuration: &configuration::Configuration, ) -> Result<models::GetProgressionTypesResponse, Error<Bf2042GetProgressionTypesBf2042ProgressiontypesGetError>> {

    let uri_str = format!("{}/bf2042/progressiontypes/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProgressionTypesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProgressionTypesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042GetProgressionTypesBf2042ProgressiontypesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_get_store_catalog_bf2042_storecatalog_get(configuration: &configuration::Configuration, ) -> Result<models::GetStoreCatalogResponse, Error<Bf2042GetStoreCatalogBf2042StorecatalogGetError>> {

    let uri_str = format!("{}/bf2042/storecatalog/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetStoreCatalogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetStoreCatalogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042GetStoreCatalogBf2042StorecatalogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_mix_info_bf2042_mixinfo_get(configuration: &configuration::Configuration, mixid: &str) -> Result<models::GetMixesByIdResponse, Error<Bf2042MixInfoBf2042MixinfoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_mixid = mixid;

    let uri_str = format!("{}/bf2042/mixinfo/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("mixid", &p_mixid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMixesByIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMixesByIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042MixInfoBf2042MixinfoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_offers_bf2042_offers_get(configuration: &configuration::Configuration, lang: Option<&str>) -> Result<models::GetOffersResponse, Error<Bf2042OffersBf2042OffersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/offers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOffersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOffersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042OffersBf2042OffersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042_playground_bf2042_playground_get(configuration: &configuration::Configuration, playgroundid: Option<&str>, experiencecode: Option<&str>, blockydata: Option<bool>, return_ownername: Option<bool>, lang: Option<&str>) -> Result<models::PlaygroundInfo, Error<Bf2042PlaygroundBf2042PlaygroundGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_playgroundid = playgroundid;
    let p_experiencecode = experiencecode;
    let p_blockydata = blockydata;
    let p_return_ownername = return_ownername;
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/playground/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_playgroundid {
        req_builder = req_builder.query(&[("playgroundid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_experiencecode {
        req_builder = req_builder.query(&[("experiencecode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_blockydata {
        req_builder = req_builder.query(&[("blockydata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_ownername {
        req_builder = req_builder.query(&[("return_ownername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlaygroundInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlaygroundInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042PlaygroundBf2042PlaygroundGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns username and avatar based on the given info
pub async fn bf2042_post_feslid_bf2042_feslid_post(configuration: &configuration::Configuration, body: serde_json::Value) -> Result<models::FeslPlayerInfo, Error<Bf2042PostFeslidBf2042FeslidPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body = body;

    let uri_str = format!("{}/bf2042/feslid/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeslPlayerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeslPlayerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042PostFeslidBf2042FeslidPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042blueprints_bf2042_scheduledblueprint_get(configuration: &configuration::Configuration, lang: Option<&str>) -> Result<models::ScheduledBlueprintResponse, Error<Bf2042blueprintsBf2042ScheduledblueprintGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/scheduledblueprint/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledBlueprintResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledBlueprintResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042blueprintsBf2042ScheduledblueprintGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042constraints_bf2042_constraints_get(configuration: &configuration::Configuration, ) -> Result<models::ConstraintsResponse, Error<Bf2042constraintsBf2042ConstraintsGetError>> {

    let uri_str = format!("{}/bf2042/constraints/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConstraintsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConstraintsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042constraintsBf2042ConstraintsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Available langauges for 'lang': ar-sa, de-de, en-us, es-es, es-mx, fr-fr, it-it, ja-jp, ko-kr, pl-pl, ru-ru, zh-cn and zh-tw. It defaults to en-us.
pub async fn bf2042detailed_servers_bf2042_detailedserver_get(configuration: &configuration::Configuration, name: Option<&str>, experiencename: Option<&str>, serverid: Option<&str>, return_ownername: Option<bool>, lang: Option<&str>) -> Result<models::Bf2042DetailedServerInfo, Error<Bf2042detailedServersBf2042DetailedserverGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_experiencename = experiencename;
    let p_serverid = serverid;
    let p_return_ownername = return_ownername;
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/detailedserver/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_experiencename {
        req_builder = req_builder.query(&[("experiencename", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_serverid {
        req_builder = req_builder.query(&[("serverid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_return_ownername {
        req_builder = req_builder.query(&[("return_ownername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf2042DetailedServerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf2042DetailedServerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042detailedServersBf2042DetailedserverGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042inventory_bf2042_inventory_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, nucleus_id: Option<i32>, platform: Option<models::KingstonPlatforms>, skip_battlelog: Option<bool>) -> Result<serde_json::Value, Error<Bf2042inventoryBf2042InventoryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_nucleus_id = nucleus_id;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bf2042/inventory/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_nucleus_id {
        req_builder = req_builder.query(&[("nucleus_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042inventoryBf2042InventoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a list of players in a array where you want stats from
pub async fn bf2042multiple_bf2042_multiple_post(configuration: &configuration::Configuration, player_info: Vec<models::PlayerInfo>, raw: Option<bool>, format_values: Option<bool>) -> Result<serde_json::Value, Error<Bf2042multipleBf2042MultiplePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_player_info = player_info;
    let p_raw = raw;
    let p_format_values = format_values;

    let uri_str = format!("{}/bf2042/multiple/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_raw {
        req_builder = req_builder.query(&[("raw", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_player_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042multipleBf2042MultiplePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042player_bf2042_player_get(configuration: &configuration::Configuration, name: &str) -> Result<models::Bf2042PlayerSearch, Error<Bf2042playerBf2042PlayerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;

    let uri_str = format!("{}/bf2042/player/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf2042PlayerSearch`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf2042PlayerSearch`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042playerBf2042PlayerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// To get multiple maps or regions, seperate them in a list with ';'.(cache of 10 seconds)
pub async fn bf2042servers_bf2042_servers_get(configuration: &configuration::Configuration, name: Option<&str>, experiencename: Option<&str>, region: Option<&str>, maps: Option<&str>, modes: Option<&str>, limit: Option<i32>, platform: Option<&str>, has_password: Option<bool>) -> Result<models::Bf2042Search, Error<Bf2042serversBf2042ServersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_experiencename = experiencename;
    let p_region = region;
    let p_maps = maps;
    let p_modes = modes;
    let p_limit = limit;
    let p_platform = platform;
    let p_has_password = has_password;

    let uri_str = format!("{}/bf2042/servers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_experiencename {
        req_builder = req_builder.query(&[("experiencename", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_maps {
        req_builder = req_builder.query(&[("maps", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modes {
        req_builder = req_builder.query(&[("modes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_has_password {
        req_builder = req_builder.query(&[("has_password", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf2042Search`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf2042Search`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042serversBf2042ServersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// You can choose to only send the playername and optional platform (defaults to pc)  or send if (playerId) nucleus_id and platform to skip name conversion
pub async fn bf2042stats_bf2042_stats_get(configuration: &configuration::Configuration, raw: Option<bool>, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, nucleus_id: Option<i32>, platform: Option<models::KingstonPlatforms>, skip_battlelog: Option<bool>) -> Result<serde_json::Value, Error<Bf2042statsBf2042StatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_raw = raw;
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_nucleus_id = nucleus_id;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bf2042/stats/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_raw {
        req_builder = req_builder.query(&[("raw", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_nucleus_id {
        req_builder = req_builder.query(&[("nucleus_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042statsBf2042StatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf2042translations_bf2042_translations_get(configuration: &configuration::Configuration, lang: Option<&str>) -> Result<models::TranslationsResponse, Error<Bf2042translationsBf2042TranslationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lang = lang;

    let uri_str = format!("{}/bf2042/translations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TranslationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TranslationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf2042translationsBf2042TranslationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn game_status_bf2042_status_get(configuration: &configuration::Configuration, ) -> Result<models::Bf2042GameStatus, Error<GameStatusBf2042StatusGetError>> {

    let uri_str = format!("{}/bf2042/status/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf2042GameStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf2042GameStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GameStatusBf2042StatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logged_server_data_bf2042_serverarray_get(configuration: &configuration::Configuration, days: Option<i32>, gameid: Option<&str>, serverid: Option<&str>, servername: Option<&str>) -> Result<serde_json::Value, Error<LoggedServerDataBf2042ServerarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_gameid = gameid;
    let p_serverid = serverid;
    let p_servername = servername;

    let uri_str = format!("{}/bf2042/serverarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_serverid {
        req_builder = req_builder.query(&[("serverid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_servername {
        req_builder = req_builder.query(&[("servername", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoggedServerDataBf2042ServerarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn print_logged_data_bf2042_statusarray_get(configuration: &configuration::Configuration, days: Option<i32>, region: Option<models::FrostbiteRegionsWithMultiple>, r#type: Option<models::ExpandedStatusArrayType>) -> Result<models::StatusArray, Error<PrintLoggedDataBf2042StatusarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_region = region;
    let p_type = r#type;

    let uri_str = format!("{}/bf2042/statusarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatusArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatusArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintLoggedDataBf2042StatusarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn statsarray_bf2042_statsarray_get(configuration: &configuration::Configuration, days: Option<i32>, name: Option<&str>, playerid: Option<i32>, nucleus_id: Option<i32>, platform: Option<models::KingstonPlatforms>, skip_battlelog: Option<bool>) -> Result<models::StatsArray, Error<StatsarrayBf2042StatsarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_name = name;
    let p_playerid = playerid;
    let p_nucleus_id = nucleus_id;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bf2042/statsarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_nucleus_id {
        req_builder = req_builder.query(&[("nucleus_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatsarrayBf2042StatsarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

