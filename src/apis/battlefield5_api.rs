/*
 * Stats API for the Battlefield series
 *
 * This project also has a <a href=\"https://top.gg/bot/714524944783900794\" target=\"_blank\">Discord bot</a>, allowing anyone in your server to check their Battlefield stats via simple commands.<br><br>Language tags (lang) for both Battlefield 1 and Battlefield 5 are based on <a href=\"https://www.oracle.com/java/technologies/javase/jdk8-jre8-suported-locales.html\" target=\"_blank\">Java 8 language tags.</a> (response keys do not change based on the language tags, only the values do).<br><br>Data for Battlefield 2 is retrieved from the two revive projects: <a href=\"https://www.bf2hub.com\" target=\"_blank\">BF2Hub</a> and <a href=\"https://playbf2.tilda.ws/en\" target=\"_blank\">PlayBF2</a>.<br><br>Data for Battlefield 2142 is retrieved from the <a href=\"https://battlefield2142.co/\" target=\"_blank\">BF2142 Reclamation</a> project.<br><br>All other titles are still managed by EA/Dice.<br><br>If you discover any issues or have suggestions for new features, post them in the Community Network Discord: <a href=\"https://discord.gg/zMuxW6c\" target=\"_blank\">discord.gg/zMuxW6c</a>.<br><br>If you want to support the project, consider <a href=\"https://github.com/sponsors/community-network\" target=\"_blank\">becoming a sponsor on GitHub</a>.
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bfv_all_bfv_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvAllBfvAllGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfv_constraints_bfv_constraints_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvConstraintsBfvConstraintsGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfv_detailed_servers_bfv_detailedserver_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvDetailedServersBfvDetailedserverGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfv_playground_bfv_playground_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvPlaygroundBfvPlaygroundGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfv_playgroundsbyowner_bfv_playgroundsbyowner_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvPlaygroundsbyownerBfvPlaygroundsbyownerGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfv_scheduledblueprint_bfv_scheduledblueprint_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvScheduledblueprintBfvScheduledblueprintGetError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvclasses_bfv_classes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvclassesBfvClassesGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvmultiple_bfv_multiple_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvmultipleBfvMultiplePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvplayers_bfv_players_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvplayersBfvPlayersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvservers_bfv_servers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvserversBfvServersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvstats_bfv_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvstatsBfvStatsGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvsus_bfv_sus_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvsusBfvSusGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvvehicles_bfv_vehicles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvvehiclesBfvVehiclesGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bfvweapons_bfv_weapons_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BfvweaponsBfvWeaponsGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logged_server_data_bfv_serverarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoggedServerDataBfvServerarrayGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_logged_data_bfv_statusarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintLoggedDataBfvStatusarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`statsarray_bfv_statsarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatsarrayBfvStatsarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`status_bfv_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatusBfvStatusGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfv_all_bfv_all_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::BfvCombined, Error<BfvAllBfvAllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BfvCombined`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BfvCombined`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvAllBfvAllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bfv_constraints_bfv_constraints_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<BfvConstraintsBfvConstraintsGetError>> {

    let uri_str = format!("{}/bfv/constraints/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvConstraintsBfvConstraintsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For platform there is pc, xboxone and ps4 (cache of 10 seconds)
pub async fn bfv_detailed_servers_bfv_detailedserver_get(configuration: &configuration::Configuration, name: Option<&str>, gameid: Option<&str>, platform: Option<models::FrostbitePlatforms>, lang: Option<&str>) -> Result<models::Bf5DetailedServerInfo, Error<BfvDetailedServersBfvDetailedserverGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_gameid = gameid;
    let p_platform = platform;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/detailedserver/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf5DetailedServerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf5DetailedServerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvDetailedServersBfvDetailedserverGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bfv_playground_bfv_playground_get(configuration: &configuration::Configuration, playgroundid: &str) -> Result<serde_json::Value, Error<BfvPlaygroundBfvPlaygroundGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_playgroundid = playgroundid;

    let uri_str = format!("{}/bfv/playground/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("playgroundid", &p_playgroundid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvPlaygroundBfvPlaygroundGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bfv_playgroundsbyowner_bfv_playgroundsbyowner_get(configuration: &configuration::Configuration, player_id: i32) -> Result<serde_json::Value, Error<BfvPlaygroundsbyownerBfvPlaygroundsbyownerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_player_id = player_id;

    let uri_str = format!("{}/bfv/playgroundsbyowner/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("player_id", &p_player_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvPlaygroundsbyownerBfvPlaygroundsbyownerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bfv_scheduledblueprint_bfv_scheduledblueprint_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<BfvScheduledblueprintBfvScheduledblueprintGetError>> {

    let uri_str = format!("{}/bfv/scheduledblueprint/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvScheduledblueprintBfvScheduledblueprintGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfvclasses_bfv_classes_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteClassStats, Error<BfvclassesBfvClassesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/classes/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteClassStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteClassStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvclassesBfvClassesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a list of player id's in a array where you want stats from (Only pc is supported)
pub async fn bfvmultiple_bfv_multiple_post(configuration: &configuration::Configuration, request_body: Vec<i32>, raw: Option<bool>, format_values: Option<bool>) -> Result<std::collections::HashMap<String, models::BfvMultiplePlayer>, Error<BfvmultipleBfvMultiplePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_body = request_body;
    let p_raw = raw;
    let p_format_values = format_values;

    let uri_str = format!("{}/bfv/multiple/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_raw {
        req_builder = req_builder.query(&[("raw", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::BfvMultiplePlayer&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::BfvMultiplePlayer&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvmultipleBfvMultiplePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bfvplayers_bfv_players_get(configuration: &configuration::Configuration, name: Option<&str>, gameid: Option<&str>) -> Result<models::BfvServerPlayers, Error<BfvplayersBfvPlayersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_gameid = gameid;

    let uri_str = format!("{}/bfv/players/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BfvServerPlayers`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BfvServerPlayers`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvplayersBfvPlayersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// ownerId is the id of the player that owns the server                         The regions available are: all (all regions), eu, asia, nam (north america), sam (south america), au (Australia) or oc (Oceana).                         For platform there is pc, xboxone and ps4 (cache of 10 seconds)                         Limit is the max amount of servers it will gather, give it a number between 1 and 200 with 10 as the default.                     For player filter you can use oneToFive, sixToTen, tenPlus or none, comma seperated list is also a option example: \"&player_filters=onetofive,sixtoten\" to filter on the amount of free slots
pub async fn bfvservers_bfv_servers_get(configuration: &configuration::Configuration, name: &str, platform: Option<models::FrostbitePlatforms>, limit: Option<i32>, region: Option<&str>, player_filters: Option<&str>, map_filters: Option<&str>, server_type_filters: Option<&str>, is_password_protected: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteSearch, Error<BfvserversBfvServersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_platform = platform;
    let p_limit = limit;
    let p_region = region;
    let p_player_filters = player_filters;
    let p_map_filters = map_filters;
    let p_server_type_filters = server_type_filters;
    let p_is_password_protected = is_password_protected;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/servers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_player_filters {
        req_builder = req_builder.query(&[("player_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_map_filters {
        req_builder = req_builder.query(&[("map_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_server_type_filters {
        req_builder = req_builder.query(&[("server_type_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_password_protected {
        req_builder = req_builder.query(&[("is_password_protected", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteSearch`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteSearch`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvserversBfvServersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfvstats_bfv_stats_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::BfvMainStats, Error<BfvstatsBfvStatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/stats/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BfvMainStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BfvMainStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvstatsBfvStatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfvsus_bfv_sus_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteSusStats, Error<BfvsusBfvSusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/sus/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteSusStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteSusStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvsusBfvSusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfvvehicles_bfv_vehicles_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteVehicleStats, Error<BfvvehiclesBfvVehiclesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/vehicles/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteVehicleStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteVehicleStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvvehiclesBfvVehiclesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bfvweapons_bfv_weapons_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteWeaponStats, Error<BfvweaponsBfvWeaponsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bfv/weapons/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteWeaponStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteWeaponStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BfvweaponsBfvWeaponsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logged_server_data_bfv_serverarray_get(configuration: &configuration::Configuration, days: Option<i32>, gameid: Option<&str>, serverid: Option<&str>, servername: Option<&str>, platform: Option<models::FrostbitePlatforms>) -> Result<serde_json::Value, Error<LoggedServerDataBfvServerarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_gameid = gameid;
    let p_serverid = serverid;
    let p_servername = servername;
    let p_platform = platform;

    let uri_str = format!("{}/bfv/serverarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_serverid {
        req_builder = req_builder.query(&[("serverid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_servername {
        req_builder = req_builder.query(&[("servername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoggedServerDataBfvServerarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Possible regions are: \"ALL\", \"EU\", \"Asia\", \"NAm\", \"SAm\", \"AU\" and \"OC\".             For platform there is \"pc\", \"xboxone\", \"ps4\" and \"all\"             For type: \"amounts\", \"maps\" (serveramount) and \"modes\" (serveramount)
pub async fn print_logged_data_bfv_statusarray_get(configuration: &configuration::Configuration, days: Option<i32>, region: Option<models::FrostbiteRegionsWithMultiple>, platform: Option<models::FrostbitePlatforms>, r#type: Option<models::StatusArrayType>) -> Result<models::FrostbiteStatusArray, Error<PrintLoggedDataBfvStatusarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_region = region;
    let p_platform = platform;
    let p_type = r#type;

    let uri_str = format!("{}/bfv/statusarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteStatusArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteStatusArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintLoggedDataBfvStatusarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn statsarray_bfv_statsarray_get(configuration: &configuration::Configuration, days: Option<i32>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>) -> Result<models::StatsArray, Error<StatsarrayBfvStatsarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bfv/statsarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatsarrayBfvStatsarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For platform there is pc, xboxone and ps4
pub async fn status_bfv_status_get(configuration: &configuration::Configuration, platform: Option<&str>) -> Result<models::FrostbiteGameStatus, Error<StatusBfvStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_platform = platform;

    let uri_str = format!("{}/bfv/status/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteGameStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteGameStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatusBfvStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

