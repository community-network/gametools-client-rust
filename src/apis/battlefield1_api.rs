/*
 * Stats API for the Battlefield series
 *
 * This project also has a <a href=\"https://top.gg/bot/714524944783900794\" target=\"_blank\">Discord bot</a>, allowing anyone in your server to check their Battlefield stats via simple commands.<br><br>Language tags (lang) for both Battlefield 1 and Battlefield 5 are based on <a href=\"https://www.oracle.com/java/technologies/javase/jdk8-jre8-suported-locales.html\" target=\"_blank\">Java 8 language tags.</a> (response keys do not change based on the language tags, only the values do).<br><br>Data for Battlefield 2 is retrieved from the two revive projects: <a href=\"https://www.bf2hub.com\" target=\"_blank\">BF2Hub</a> and <a href=\"https://playbf2.tilda.ws/en\" target=\"_blank\">PlayBF2</a>.<br><br>Data for Battlefield 2142 is retrieved from the <a href=\"https://battlefield2142.co/\" target=\"_blank\">BF2142 Reclamation</a> project.<br><br>All other titles are still managed by EA/Dice.<br><br>If you discover any issues or have suggestions for new features, post them in the Community Network Discord: <a href=\"https://discord.gg/zMuxW6c\" target=\"_blank\">discord.gg/zMuxW6c</a>.<br><br>If you want to support the project, consider <a href=\"https://github.com/sponsors/community-network\" target=\"_blank\">becoming a sponsor on GitHub</a>.
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bf1_all_bf1_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1AllBf1AllGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1classes_bf1_classes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1classesBf1ClassesGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1detailedservers_bf1_detailedserver_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1detailedserversBf1DetailedserverGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1gamemode_bf1_gamemode_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1gamemodeBf1GamemodeGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1multiple_bf1_multiple_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1multipleBf1MultiplePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1player_bf1_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1playerBf1PlayerGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1players_bf1_players_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1playersBf1PlayersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1progress_bf1_progress_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1progressBf1ProgressGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1seederplayers_bf1_seederplayers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1seederplayersBf1SeederplayersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1servers_bf1_servers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1serversBf1ServersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1stats_bf1_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1statsBf1StatsGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1sus_bf1_sus_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1susBf1SusGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1vehicles_bf1_vehicles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1vehiclesBf1VehiclesGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf1weapons_bf1_weapons_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf1weaponsBf1WeaponsGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logged_server_data_bf1_serverarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoggedServerDataBf1ServerarrayGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_logged_data_bf1_statusarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintLoggedDataBf1StatusarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`statsarray_bf1_statsarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatsarrayBf1StatsarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`status_bf1_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatusBf1StatusGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1_all_bf1_all_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::Bf1Combined, Error<Bf1AllBf1AllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf1Combined`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf1Combined`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1AllBf1AllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1classes_bf1_classes_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteClassStats, Error<Bf1classesBf1ClassesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/classes/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteClassStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteClassStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1classesBf1ClassesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For platform there is pc, xboxone and ps4 (cache of 10 seconds)
pub async fn bf1detailedservers_bf1_detailedserver_get(configuration: &configuration::Configuration, name: Option<&str>, gameid: Option<&str>, platform: Option<models::FrostbitePlatforms>, lang: Option<&str>) -> Result<models::Bf1DetailedServerInfo, Error<Bf1detailedserversBf1DetailedserverGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_gameid = gameid;
    let p_platform = platform;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/detailedserver/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf1DetailedServerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf1DetailedServerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1detailedserversBf1DetailedserverGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1gamemode_bf1_gamemode_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::GamemodeStats, Error<Bf1gamemodeBf1GamemodeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/gamemode/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GamemodeStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GamemodeStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1gamemodeBf1GamemodeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a list of player id's in a array where you want stats from (Only pc is supported)
pub async fn bf1multiple_bf1_multiple_post(configuration: &configuration::Configuration, request_body: Vec<i32>, raw: Option<bool>, format_values: Option<bool>) -> Result<std::collections::HashMap<String, models::Bf1MultiplePlayer>, Error<Bf1multipleBf1MultiplePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request_body = request_body;
    let p_raw = raw;
    let p_format_values = format_values;

    let uri_str = format!("{}/bf1/multiple/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_raw {
        req_builder = req_builder.query(&[("raw", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Bf1MultiplePlayer&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::Bf1MultiplePlayer&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1multipleBf1MultiplePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1player_bf1_player_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>) -> Result<models::PersonaInfo, Error<Bf1playerBf1PlayerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bf1/player/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PersonaInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PersonaInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1playerBf1PlayerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn bf1players_bf1_players_get(configuration: &configuration::Configuration, name: Option<&str>, gameid: Option<&str>) -> Result<models::Bf1ServerPlayers, Error<Bf1playersBf1PlayersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_gameid = gameid;

    let uri_str = format!("{}/bf1/players/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf1ServerPlayers`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf1ServerPlayers`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1playersBf1PlayersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1progress_bf1_progress_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::ProgressStats, Error<Bf1progressBf1ProgressGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/progress/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProgressStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProgressStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1progressBf1ProgressGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This returns some extra info that can only be gathered from a real game session: score, kills and deaths.              Use the one above as backup, as it only returns when someone has a sender running
pub async fn bf1seederplayers_bf1_seederplayers_get(configuration: &configuration::Configuration, name: Option<&str>, id: Option<&str>, gameid: Option<i32>) -> Result<models::Bf1SeederServerPlayers, Error<Bf1seederplayersBf1SeederplayersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_id = id;
    let p_gameid = gameid;

    let uri_str = format!("{}/bf1/seederplayers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf1SeederServerPlayers`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf1SeederServerPlayers`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1seederplayersBf1SeederplayersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// ownerId == None, can't be gathered for bf1. used in bf5.                     The regions available are: all (all regions), eu, asia, nam (north america), sam (south america), au (Australia) or oc (Oceana).                     For platform there is pc, xboxone and ps4 (cache of 10 seconds)                     For player filter you can use oneToFive, sixToTen, tenPlus or none, comma seperated list is also a option example: \"&player_filters=onetofive,sixtoten\" to filter on the amount of free slots.                     Same for gamemode filter as with player filter but with the name of the gamemode
pub async fn bf1servers_bf1_servers_get(configuration: &configuration::Configuration, name: &str, platform: Option<models::FrostbitePlatforms>, limit: Option<i32>, region: Option<&str>, gamemode_filters: Option<&str>, map_filters: Option<&str>, player_filters: Option<&str>, server_type_filters: Option<&str>, is_password_protected: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteSearch, Error<Bf1serversBf1ServersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_platform = platform;
    let p_limit = limit;
    let p_region = region;
    let p_gamemode_filters = gamemode_filters;
    let p_map_filters = map_filters;
    let p_player_filters = player_filters;
    let p_server_type_filters = server_type_filters;
    let p_is_password_protected = is_password_protected;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/servers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gamemode_filters {
        req_builder = req_builder.query(&[("gamemode_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_map_filters {
        req_builder = req_builder.query(&[("map_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_player_filters {
        req_builder = req_builder.query(&[("player_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_server_type_filters {
        req_builder = req_builder.query(&[("server_type_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_password_protected {
        req_builder = req_builder.query(&[("is_password_protected", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteSearch`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteSearch`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1serversBf1ServersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1stats_bf1_stats_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteMainStats, Error<Bf1statsBf1StatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/stats/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteMainStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteMainStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1statsBf1StatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1sus_bf1_sus_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteSusStats, Error<Bf1susBf1SusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/sus/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteSusStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteSusStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1susBf1SusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1vehicles_bf1_vehicles_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteVehicleStats, Error<Bf1vehiclesBf1VehiclesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/vehicles/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteVehicleStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteVehicleStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1vehiclesBf1VehiclesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// you only have to fill in one of them: oid (used in bfban: 'https://bfban.com/#/cheaters/1008084550936'), name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur
pub async fn bf1weapons_bf1_weapons_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>, lang: Option<&str>) -> Result<models::FrostbiteWeaponStats, Error<Bf1weaponsBf1WeaponsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;
    let p_lang = lang;

    let uri_str = format!("{}/bf1/weapons/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteWeaponStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteWeaponStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf1weaponsBf1WeaponsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logged_server_data_bf1_serverarray_get(configuration: &configuration::Configuration, days: Option<i32>, gameid: Option<&str>, serverid: Option<&str>, servername: Option<&str>, platform: Option<models::FrostbitePlatforms>) -> Result<serde_json::Value, Error<LoggedServerDataBf1ServerarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_gameid = gameid;
    let p_serverid = serverid;
    let p_servername = servername;
    let p_platform = platform;

    let uri_str = format!("{}/bf1/serverarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_serverid {
        req_builder = req_builder.query(&[("serverid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_servername {
        req_builder = req_builder.query(&[("servername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoggedServerDataBf1ServerarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn print_logged_data_bf1_statusarray_get(configuration: &configuration::Configuration, days: Option<i32>, region: Option<models::FrostbiteRegionsWithMultiple>, platform: Option<models::FrostbitePlatforms>, r#type: Option<models::StatusArrayType>) -> Result<models::FrostbiteStatusArray, Error<PrintLoggedDataBf1StatusarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_region = region;
    let p_platform = platform;
    let p_type = r#type;

    let uri_str = format!("{}/bf1/statusarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteStatusArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteStatusArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintLoggedDataBf1StatusarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn statsarray_bf1_statsarray_get(configuration: &configuration::Configuration, days: Option<i32>, name: Option<&str>, playerid: Option<i32>, oid: Option<i32>, platform: Option<models::FrostbitePlatforms>, skip_battlelog: Option<bool>) -> Result<models::StatsArray, Error<StatsarrayBf1StatsarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_name = name;
    let p_playerid = playerid;
    let p_oid = oid;
    let p_platform = platform;
    let p_skip_battlelog = skip_battlelog;

    let uri_str = format!("{}/bf1/statsarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_oid {
        req_builder = req_builder.query(&[("oid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_battlelog {
        req_builder = req_builder.query(&[("skip_battlelog", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatsarrayBf1StatsarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For platform there is pc, xboxone and ps4
pub async fn status_bf1_status_get(configuration: &configuration::Configuration, platform: Option<&str>) -> Result<models::FrostbiteGameStatus, Error<StatusBf1StatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_platform = platform;

    let uri_str = format!("{}/bf1/status/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteGameStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteGameStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatusBf1StatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

