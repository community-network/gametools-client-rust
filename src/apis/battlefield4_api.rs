/*
 * Stats API for the Battlefield series
 *
 * This project also has a <a href=\"https://top.gg/bot/714524944783900794\" target=\"_blank\">Discord bot</a>, allowing anyone in your server to check their Battlefield stats via simple commands.<br><br>Language tags (lang) for both Battlefield 1 and Battlefield 5 are based on <a href=\"https://www.oracle.com/java/technologies/javase/jdk8-jre8-suported-locales.html\" target=\"_blank\">Java 8 language tags.</a> (response keys do not change based on the language tags, only the values do).<br><br>Data for Battlefield 2 is retrieved from the two revive projects: <a href=\"https://www.bf2hub.com\" target=\"_blank\">BF2Hub</a> and <a href=\"https://playbf2.tilda.ws/en\" target=\"_blank\">PlayBF2</a>.<br><br>Data for Battlefield 2142 is retrieved from the <a href=\"https://battlefield2142.co/\" target=\"_blank\">BF2142 Reclamation</a> project.<br><br>All other titles are still managed by EA/Dice.<br><br>If you discover any issues or have suggestions for new features, post them in the Community Network Discord: <a href=\"https://discord.gg/zMuxW6c\" target=\"_blank\">discord.gg/zMuxW6c</a>.<br><br>If you want to support the project, consider <a href=\"https://github.com/sponsors/community-network\" target=\"_blank\">becoming a sponsor on GitHub</a>.
 *
 * The version of the OpenAPI document: 1.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`bf4_all_bf4_all_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4AllBf4AllGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf4detailedserver_bf4_detailedserver_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4detailedserverBf4DetailedserverGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf4servers_bf4_servers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4serversBf4ServersGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf4stats_bf4_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4statsBf4StatsGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf4vehicles_bf4_vehicles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4vehiclesBf4VehiclesGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bf4weapons_bf4_weapons_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Bf4weaponsBf4WeaponsGetError {
    Status404(),
    Status502(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logged_server_data_bf4_serverarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoggedServerDataBf4ServerarrayGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`print_logged_data_bf4_statusarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrintLoggedDataBf4StatusarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`statsarray_bf4_statsarray_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatsarrayBf4StatsarrayGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`status_bf4_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatusBf4StatusGetError {
    Status404(),
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// Available options for platform: pc, ps3, ps4, xbox360, xboxone.  for nametypes you only have to fill in one of them: name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur&platform=pc
pub async fn bf4_all_bf4_all_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, platform: Option<&str>) -> Result<models::Bf4Combined, Error<Bf4AllBf4AllGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf4Combined`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf4Combined`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4AllBf4AllGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For platform there is pc, xboxone and ps4. players is only for pc (has longer cache, 1 mins)
pub async fn bf4detailedserver_bf4_detailedserver_get(configuration: &configuration::Configuration, name: Option<&str>, gameid: Option<&str>, platform: Option<models::FrostbitePlatforms>, lang: Option<&str>) -> Result<models::Bf4DetailedServerInfo, Error<Bf4detailedserverBf4DetailedserverGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_gameid = gameid;
    let p_platform = platform;
    let p_lang = lang;

    let uri_str = format!("{}/bf4/detailedserver/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf4DetailedServerInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf4DetailedServerInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4detailedserverBf4DetailedserverGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The regions available are: all (all regions), eu, asia, nam (north america), sam (south america), au (Australia) or oc (Oceana).                     For platform there is pc, xboxone and ps4 (cache of 10 seconds)                     Limit is the max amount of servers it will gather, give it a number between 1 and 100.                     For player filter you can use oneToFive, sixToTen, tenPlus or none, comma seperated list is also a option example: \"&player_filters=onetofive,sixtoten\" to filter on the amount of free slots.                     Same for gamemode filter as with player filter but with the name of the gamemode
pub async fn bf4servers_bf4_servers_get(configuration: &configuration::Configuration, name: &str, platform: Option<models::FrostbitePlatforms>, limit: Option<i32>, region: Option<&str>, gamemode_filters: Option<&str>, player_filters: Option<&str>, server_type_filters: Option<&str>, is_password_protected: Option<bool>, lang: Option<&str>) -> Result<models::Bf4Search, Error<Bf4serversBf4ServersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_platform = platform;
    let p_limit = limit;
    let p_region = region;
    let p_gamemode_filters = gamemode_filters;
    let p_player_filters = player_filters;
    let p_server_type_filters = server_type_filters;
    let p_is_password_protected = is_password_protected;
    let p_lang = lang;

    let uri_str = format!("{}/bf4/servers/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gamemode_filters {
        req_builder = req_builder.query(&[("gamemode_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_player_filters {
        req_builder = req_builder.query(&[("player_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_server_type_filters {
        req_builder = req_builder.query(&[("server_type_filters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_password_protected {
        req_builder = req_builder.query(&[("is_password_protected", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_lang {
        req_builder = req_builder.query(&[("lang", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Bf4Search`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Bf4Search`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4serversBf4ServersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Available options for platform: pc, ps3, ps4, xbox360, xboxone.  for nametypes you only have to fill in one of them: name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur&platform=pc
pub async fn bf4stats_bf4_stats_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, platform: Option<&str>) -> Result<models::FrostbiteMainStats, Error<Bf4statsBf4StatsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/stats/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FrostbiteMainStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FrostbiteMainStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4statsBf4StatsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Available options for platform: pc, ps3, ps4, xbox360, xboxone.  for nametypes you only have to fill in one of them: name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur&platform=pc
pub async fn bf4vehicles_bf4_vehicles_get(configuration: &configuration::Configuration, name: Option<&str>, playerid: Option<i32>, platform: Option<&str>) -> Result<models::BattlelogVehicleStats, Error<Bf4vehiclesBf4VehiclesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_playerid = playerid;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/vehicles/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BattlelogVehicleStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BattlelogVehicleStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4vehiclesBf4VehiclesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Available options for platform: pc, ps3, ps4, xbox360, xboxone.  for nametypes you only have to fill in one of them: name (normal playername), or playerid (same as id in what it returns - fastest method).  if you dont know what you need to use, just use 'name', just fill the playername in there: **_/stats/?name=iiTzArcur&platform=pc
pub async fn bf4weapons_bf4_weapons_get(configuration: &configuration::Configuration, format_values: Option<bool>, name: Option<&str>, playerid: Option<i32>, platform: Option<&str>) -> Result<models::BattlelogWeaponStats, Error<Bf4weaponsBf4WeaponsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format_values = format_values;
    let p_name = name;
    let p_playerid = playerid;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/weapons/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format_values {
        req_builder = req_builder.query(&[("format_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BattlelogWeaponStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BattlelogWeaponStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Bf4weaponsBf4WeaponsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logged_server_data_bf4_serverarray_get(configuration: &configuration::Configuration, days: Option<i32>, gameid: Option<&str>, serverid: Option<&str>, servername: Option<&str>, platform: Option<models::FrostbitePlatforms>) -> Result<serde_json::Value, Error<LoggedServerDataBf4ServerarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_gameid = gameid;
    let p_serverid = serverid;
    let p_servername = servername;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/serverarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_gameid {
        req_builder = req_builder.query(&[("gameid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_serverid {
        req_builder = req_builder.query(&[("serverid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_servername {
        req_builder = req_builder.query(&[("servername", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoggedServerDataBf4ServerarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Possible regions are: \"ALL\", \"EU\", \"Asia\", \"NAm\", \"SAm\", \"AU\" and \"OC\".             For platform there is \"pc\", \"xboxone\", \"ps4\" and \"all\"             For type: \"amounts\", \"maps\" (serveramount) and \"modes\" (serveramount)
pub async fn print_logged_data_bf4_statusarray_get(configuration: &configuration::Configuration, days: Option<i32>, region: Option<models::FrostbiteRegionsWithMultiple>, platform: Option<models::FrostbitePlatforms>, r#type: Option<models::StatusArrayType>) -> Result<models::StatusArray, Error<PrintLoggedDataBf4StatusarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_region = region;
    let p_platform = platform;
    let p_type = r#type;

    let uri_str = format!("{}/bf4/statusarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatusArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatusArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrintLoggedDataBf4StatusarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn statsarray_bf4_statsarray_get(configuration: &configuration::Configuration, days: Option<i32>, name: Option<&str>, playerid: Option<i32>, platform: Option<&str>) -> Result<models::StatsArray, Error<StatsarrayBf4StatsarrayGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_days = days;
    let p_name = name;
    let p_playerid = playerid;
    let p_platform = platform;

    let uri_str = format!("{}/bf4/statsarray/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_playerid {
        req_builder = req_builder.query(&[("playerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsArray`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsArray`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatsarrayBf4StatsarrayGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn status_bf4_status_get(configuration: &configuration::Configuration, platform: Option<&str>) -> Result<models::GameStatus, Error<StatusBf4StatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_platform = platform;

    let uri_str = format!("{}/bf4/status/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GameStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GameStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatusBf4StatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

